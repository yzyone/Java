﻿﻿# JVM占用VIRT虚拟内存高问题研究原文链接：[https://my.oschina.net/LucasZhu/blog/1818013](https://my.oschina.net/LucasZhu/blog/1818013)---### 1. 现象最近发现线上机器 java 8 进程的 VIRT 虚拟内存使用达到了 11G+，如下图所示：```Tasks: 661 total,   1 running, 657 sleeping,   3 stopped,   0 zombie%Cpu(s):  0.2 us,  0.3 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem : 65553528 total, 54411416 free,  5244096 used,  5898016 buff/cacheKiB Swap: 32899068 total, 32899068 free,        0 used. 59579928 avail Mem    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                               103980 dell      20   0 2680312 614056  71492 S   2.3  0.9  19:32.51 Web Content                                                             7511 dell      20   0  162568   2892   1584 R   1.0  0.0   0:00.09 top                                                                   103535 dell      20   0 2633772 422000  84548 S   1.0  0.6  11:06.15 firefox                                                                 6957 dell      20   0 11.7g   1.1g  20500 S   0.7  1.8   1:37.69 java                                                                   10660 root      20   0 2485492  45332   4396 S   0.7  0.1   5:00.75 mirrord                                                                10825 root      20   0  722820   3224   1972 S   0.7  0.0   6:05.13 hasvrd                                                                    10 root      20   0       0      0      0 S   0.3  0.0   1:40.43 rcu_sched                                                               9124 root      12  -8   84556    916    776 S   0.3  0.0   0:00.27 audispd                                                                 9198 qtss      20   0  393924   4604   1488 S   0.3  0.0   2:55.89 DarwinStreaming                                                        11189 root      20   0  588804  62560   5400 S   0.3  0.1   0:35.19 gunicorn            ```### 2. 不管用的 -Xmx首先第一想到的当然使用 java 的 -Xmx 去限制堆的使用。但是无论怎样设置，都没有什么效果。没办法，只好开始苦逼的研究。### 3. 什么是 VIRT现代操作系统里面分配虚拟地址空间操作不同于分配物理内存。在64位操作系统上，可用的最大虚拟地址空间有16EB，即大概180亿GB。那么在一台只有16G的物理内存的机器上，我也能要求获得4TB的地址空间以备将来使用。例如：```void *mem = mmap(0, 4ul * 1024ul * 1024ul * 1024ul * 1024ul,                     PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE,                     -1, 0);```当使用 mmap 并设置 MAP_NORESERVE 标志时，并不会要求实际的物理内存和swap空间存在。所以上述代码可以在top中看到使用了 4096g 的 VIRT 虚拟内存，这当然是不可能的，它只是表示使用了 4096GB 的地址空间而已。### 4. 为什么会用这么多地址空间那 Java 程序为什么会使用这么多的地址空间呢？使用“pmap -x”来查看一下:```…00007ff638021000   65404       0       0 -----    [ anon ]00007ff63c000000     132      36      36 rw---    [ anon ]00007ff63c021000   65404       0       0 -----    [ anon ]00007ff640000000     132      28      28 rw---    [ anon ]00007ff640021000   65404       0       0 -----    [ anon ]00007ff644000000     132       8       8 rw---    [ anon ]00007ff644021000   65404       0       0 -----    [ anon ]00007ff648000000     184     184     184 rw---    [ anon ]00007ff64802e000   65352       0       0 -----    [ anon ]00007ff64c000000     132     100     100 rw---    [ anon ]00007ff64c021000   65404       0       0 -----    [ anon ]00007ff650000000     132      56      56 rw---    [ anon ]00007ff650021000   65404       0       0 -----    [ anon ]00007ff654000000     132      16      16 rw---    [ anon ]00007ff654021000   65404       0       0 -----    [ anon ]…```发现有很多奇怪的64MB的内存映射，查资料发现这是 glibc 在版本 2.10 引入的 arena 新功能导致。CentOS 6/7 的 glibc 大都是 2.12/ 2.17 了，所以都会有这个问题。这个功能对每个线程都分配一个分配一个本地arena来加速多线程的执行。在 glibc 的 arena.c 中使用的 mmap() 调用就和之前的示例代码类似：```    p2 = (char *)mmap(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,                          MAP_NORESERVE | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)```之后，只有很小的一部分地址被映射到了物理内存中：```    mprotect(p2, size, PROT_READ | PROT_WRITE)```因此在一个多线程程序中，会有相当多的 64MB 的 arena 被分配。这个可以用环境变量 `MALLOC_ARENA_MAX` 来控制。在64位系统中的默认值为 128。### 5. Java 的特殊性Java 程序由于自己维护堆的使用，导致调用 glibc 去管理内存的次数较少。更糟的是 Java 8 开始使用 metaspace 原空间取代永久代，而元空间是存放在操作系统本地内存中，那线程一多，每个线程都要使用一点元空间，每个线程都分配一个 arena，每个都64MB，就会导致巨大的虚拟地址被分配。从glibc2.11版本开始，linux为了解决多线程下内存分配竞争而引起的性能问题，增强了动态内存分配行为，使用了一种叫做arena的memory pool,在64位系统下面缺省配置是一个arena大小为64M，一个进程可以最多有cpu cores * 8个arena。假设机器是8核的，那么最多可以有8 * 8 = 64个arena，也就是会使用64 * 64 = 4096M内存。然而我们可以通过设置系统环境变量来改变arena的数量：```export MALLOC_ARENA_MAX=8（一般建议配置程序cpu核数）```### 6. 结束语总结一下：VIRT高是因为分配了太多地址空间导致。一般来说不用太在意VIRT太高，因为你有16EB的空间可以使用。如果你实在需要控制VIRT的使用，设置环境变量`MALLOC_ARENA_MAX`，例如hadoop推荐值为4，因为YARN使用VIRT值监控资源使用。